---
output:
  md_document:
    variant: markdown_github
---

## qrbp is an r package for generating quasi random background points for Poisson point process models.

The package aims to generate quasi-random background point for use in Poisson point process models. Quasi-random points are an alternative to grid-based or random background point designs. Quasi-random (sampling) background points are an advanced form of spatially-balanced survey design or point stratification, that aims to reduce the frequency of placing samples close to each other (relative to simple randomisations or grid designs). A quasi-random background point design improves efficiency of background point sampling (and subsequent modelling) by reducing the amount of spatial auto-correlation between data implying that each sample is providing as much unique information as possible (Grafston & Tille, 2013) and thus reducing low
errors for geostatistical prediction (Diggle & Ribeiro, 2007).

```{r install, eval=FALSE}
devtools::install_github('skiptoniam/qrbp')
```

There are two main functions in the `qrbp` package, the first and main function can be used to generate background points within a spatial domain. Generation of background points can be used in Poisson point process modelling in R. The main function is `generate_background_points`, which takes a Raster* as a study area, covariates - which are a Raster stack on the of the same resolution and extent as the study area.

Import some species data and covariates for modelling
```{r,message=FALSE}
library(sdm)
library(raster)

file <- system.file("external/species.shp", package="sdm") # 
species <- shapefile(file)
path <- system.file("external", package="sdm") # path to the folder contains the data
lst <- list.files(path=path,pattern='asc$',full.names = T) 
preds <- stack(lst)
projection(preds) <- "+proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +a=6378137 +b=6378137 +units=m +no_defs"
```

plot the presence only data (occurrences==1), in the dataset we have the luxury of absences which means that if you were going to model this species correctly, you could do it using absences and have no need generate background points.
```{r}
plot(preds[[1]])
points(species[species$Occurrence == 1,],col='red',pch=16,cex=.5)
```

For a laugh, let's generate some quasirandom background points and plot them against the presence points. Here we are using the `quasirandom_covariates` method which tries to select quasirandom points across geographic and environmental space. The other working methods are `quasirandom` which just creates quasirandom points spatially, or `grid` which creates a regular grid at a set resolution - this is every similar to the grid design proposed by Warton *et al.,* 2010.
```{r}
library(qrbp)
POdata <- species[species$Occurrence == 1,]
bkpts_quasi <- generate_background_points(number_of_background_points = 300,
                                    known_sites = POdata@coords,
                                    study_area = preds[[1]],
                                    model_covariates = preds,
                                    method = 'quasirandom_covariates')
```

For a laugh, let's generate some quasirandom background points and plot them against the presence points
```{r}
library(qrbp)
POdata <- species[species$Occurrence == 1,]
bkpts_grid <- generate_background_points(known_sites = POdata@coords,
                                    study_area = preds[[1]],
                                    model_covariates = preds,
                                    resolution = 16000, # this needs to be relative to raster resolution - this is about half the input resolution of the raster.
                                    method = 'grid')
```

Now let's plot our background points. We can see on the left plot that the points look randomly distributed, these are the quasi-random background points. While the right plot is a regular grid.
```{r}
par(mfrow=c(1,2))
plot(preds[[1]])
points(bkpts_quasi[bkpts_quasi$presence == 0,c("x","y")],col='blue',pch=16,cex=.3)
points(bkpts_quasi[bkpts_quasi$presence == 1,c("x","y")],col='red',pch=16,cex=.6)
plot(preds[[1]])
points(bkpts_grid[bkpts_grid$presence == 0,c("x","y")],col='blue',pch=16,cex=.3)
points(bkpts_grid[bkpts_grid$presence == 1,c("x","y")],col='red',pch=16,cex=.6)

```

Now let's try and generate a ppm using a Poisson gam. We are going to need more integration points (background points) in order to develop a robust Poisson Point Process model. If you look at the great Fithian & Hastie (2014) or Warton & Shepard (2010) papers they show that if you start to approach an infinite number of integration points you should converge on the correct estimate of the intensity of occurrence (not quite correct) within the study region. Infinity is a big number - so how about we aim for about 20,000 background points. If are getting close the summed relative likelihood of occurrence should approximately equal the number of presence points, in this case study 94 occurrence points.
```{r, warning=FALSE}
library(mgcv)
bkpts_quasi <- generate_background_points(number_of_background_points = 20000,
                                    known_sites = POdata@coords,
                                    study_area = preds[[1]],
                                    model_covariates = preds,
                                    method = 'quasirandom_covariates')
fm1 <- gam(presence ~ s(elevation) +
              s(precipitation) +
              s(temperature) +
              s(vegetation) + offset(log(weights)),
              # weights = weights,
              data = bkpts_quasi,
              family = poisson())

p1 <- predict(object=preds,
             model=fm1,
             type = 'response',
             const=data.frame(weights = 1))

p1_cell <- p1*(res(preds)[1]*res(preds)[2])
POdata <- species[species$Occurrence == 1,]
bkpts_grid <- generate_background_points(known_sites = POdata@coords,
                                    study_area = preds[[1]],
                                    model_covariates = preds,
                                    resolution = 2110, # this needs to be relative to raster resolution - this is about half the input resolution of the raster.
                                    method = 'grid')

fm2 <- gam(presence ~ s(elevation) +
              s(precipitation) +
              s(temperature) +
              s(vegetation) + 
              offset(log(weights)),
              data = bkpts_grid,
              family = poisson())

p2 <- predict(object=preds,
             model=fm2,
             type = 'response',
             const=data.frame(weights = 1))

p2_cell <- p2*(res(preds)[1]*res(preds)[2])

plot(p2_cell)

fm_warton2010 <- gam(presence/weights ~ s(elevation) +
              s(precipitation) +
              s(temperature) +
              s(vegetation),
              weights = weights,
              data = bkpts_grid,
              family = poisson())

p_warton <- predict(object=preds,
             model=fm_warton2010,
             type = 'response',
             const=data.frame(weights = 1))

p_warton_cell <- p_warton*(res(preds)[1]*res(preds)[2])


```

Now let's plot these models.
```{r,fig.width=12,fig.height=6}
jet.colors <- colorRampPalette(rev(RColorBrewer::brewer.pal(11 , "Spectral")))
par(mfrow=c(1,3),oma=c(4,4,4,4))
plot(p1_cell,col=jet.colors(100),main='quasi_random offset')
plot(p2_cell,col=jet.colors(100),main='grid offset')
plot(p_warton_cell,col=jet.colors(100),main='grid ala Warton2010')
```

Let's buld a PA species distribution based on the actuall occurrence data and see how we go.
```{r,message=FALSE,error=FALSE,warning=FALSE}
d <- sdmData(formula= ~., train=species, predictors=preds)
dat <- cbind(species$Occurrence,d@features)
colnames(dat)[1]<-'occurrence'
fm3 <- gam(occurrence ~ s(elevation) +
              s(precipitation) +
              s(temperature) +
              s(vegetation),
              data = dat,
              family = binomial())

p3 <- predict(object=preds,
             model=fm3,
             type = 'response')
```

Now let's compare the spatial predictions of the PPM against the PA species distribution model, hopefully we are in the right ball park.
```{r,fig.width=10,fig.height=8}
jet.colors <- colorRampPalette(rev(RColorBrewer::brewer.pal(11 , "Spectral")))
par(mfrow=c(2,2),oma=c(4,4,4,4))
plot(p1_cell,col=jet.colors(100),main='quasi_random offset')
plot(p2_cell,col=jet.colors(100),main='grid offset')
plot(p_warton_cell,col=jet.colors(100),main='grid ala Warton2010')
plot(p3,col=jet.colors(100),main='Bernoulli PA gam')
```

### Part two - estimating inclusion probabilities to use as a bias layer. (not finished yet)

In section 2.5 *Identifiability and sampling bias* from Fithian & Hastie (2014), they discuss the challanging concept of accounting for sampling bias in presence-only models. The discuss the idea of obtaining the *observation process*, which is difficult to do, as prence-only data only really contains information on the *sighting process* (absences aren't explicitly records and we only have information on sightings).  

`estimate_bias_layer` is a function which can be used to inform the selection of quasirandom bias points to be used in as a bias offset in PPM modelling. 

Here is an example using a set of spatial points and a raster. In this example we use the location of the existing sample sites to help generate a new set of back ground points based on an underlying probability of sampling intensity. The probability of estimating the probability of presence from a series of spatial points. The probability of *absence in an area of size A* according to the Poisson distribution is:

$pr(y=0) = exp(-\lambda(u)*A)$

The prob of *presence* is then:

$pr( y=1) = 1-pr(y=0)$
         $= 1-exp(-\lambda(u)*A)$
         
where $\lambda(u)$ = the intensity value at point $u$ and $A$ is the area of the sampling unit (cell size). $\lambda$ is estimated using `density.ppp` from the spatstat package and then converted into a `inclusion.prob` to inform quasi-random background point selection.

Here we can use the example data from above to set up a layer that will inform inclusion.probabilities for quasirandom background points. In this example, I'm using the absence data too, in reality you'd just construct a presence-absence model - but I thought it'd be fun to play with a bit more data.

```{r}
bias_layer <- estimate_bias_layer(known_sites = species@coords,
                                  study_area = preds[[1]],
                                  sigma = 10000)

```

Now let's generate some back ground points using our bias layer
```{r}
bkpts_bias <- generate_background_points(number_of_background_points = 1000,
                                    known_sites = POdata@coords,
                                    study_area = preds[[1]],
                                    model_covariates = preds,
                                    bias_layer = bias_layer,
                                    method = 'bias')

plot(preds[[1]])
points(bkpts_bias[bkpts_bias$presence==0,c("x","y")],cex=.5,pch=16)
```

Now let's try and fit a model. Looking pretty good and we only used 1000 background points. 
```{r}

fm4 <- gam(presence ~ s(elevation) +
              s(precipitation) +
              s(temperature) +
              s(vegetation) + 
              offset(log(weights)),
              data = bkpts_bias,
              family = poisson())

p4 <- predict(object=preds,
             model=fm4,
             type = 'response',
             const=data.frame(weights = 1))

p4_cell <- p4*(res(preds)[1]*res(preds)[2])

plot(p4_cell)
```

### References 

Diggle, P. J., P. J. Ribeiro, Model-based Geostatistics. Springer Series in Statistics. Springer, 2007.

Fithian, William, and Trevor Hastie. "Local case-control sampling: Efficient subsampling in imbalanced data sets." Annals of statistics 42.5 (2014): 1693.

Grafström, Anton, and Yves Tillé. "Doubly balanced spatial sampling with spreading and restitution of auxiliary totals." Environmetrics 24.2 (2013): 120-131.

Warton, D. I., and L. C. Shepherd. "Poisson point process models solve the pseudo-absence problem for presence-only data in ecology." The Annals of Applied Statistics 4.3 (2010): 1383-1402.
